\documentclass[11pt,a4paper]{report} 
% Alternativ für doppelseitigen Ausdruck (nur bei > 60 Seiten sinnvoll)
% \documentclass[11pt,a4paper,twoside,openright]{report} 
\usepackage{mathtools}
\usepackage{amssymb} 

\include{preamble} % alle Pakete und Einstellungen

% Hier anpassen 
\newcommand{\welchethesis}{Bachelor}
% \newcommand{\welchethesis}{Master}
\newcommand{\thesisofwas}{of Science - B.Sc.}
\newcommand{\titel}{Study and implementation of a decentralized application that can provide
	permissionless financial services using an evm based blockchain}
%\newcommand{\kurztitel}{Template Abschlussarbeit}
\newcommand{\autor}{Mario Alberto Maita Orozco}
\newcommand{\datum}{30.06.2022} % Abgabedatum
\newcommand{\ort}{Wiesbaden}
\newcommand{\referent}{Prof.\ Dr.\ Eva-Maria Iwer}
\newcommand{\korreferent}{Prof.\ Dr.\ Marc-Alexander Zschiegner}
%\usepackage{tabularx}
\usepackage{enumitem}
\usepackage{hyperref}
\hypersetup{
	colorlinks=true,
	linkcolor=blue,
	filecolor=magenta,      
	urlcolor=cyan,
	citecolor=blue,
%	pdftitle={Overleaf Example},
%	pdfpagemode=FullScreen,
}
\begin{document}
\include{vorspann} % Titelseite, Erklärungen, etc.

\begin{abstract} 
abstract
\end{abstract}

\tableofcontents
\newpage 

\chapter{Introduction} \label{ch:intro}
%\epigraphhead[70]{\epigraph{Documentation is like sex: 
%when it is good, it is very, very good; and when it is bad, 
%sit is better than nothing.}{\textit{Dick Brandon}}}



\section{Motivation}
In the last years' blockchain technology has gained a lot of traction and many developers are willing to build applications on top of this technology.
The Ethereum network with the Ethereum Virtual Machine, or EVM~\ref{sec:evm}, (whose state is validated and copied by every node of the network) offers a new way of application development. Meaning that developers can now implement some functionality and deploy it to a public EVM blockchain, making the code/functionality tamper-resistant; in addition, the implemented functionality (or smart contract) can be called by any participant or other code/contracts within the network. This composability allows anyone to interact with already deployed contracts and build other applications on top of them. 
These kinds of applications are called Decentralized applications or Dapps~\ref{sec:dapps}, because they are built on top of a decentralized network such as  Ethereum.
\section{Goals}
The goals of this Thesis are, to study and provide a better understanding of: 
\begin{itemize}
	\item How Dapps are built.
	\item Which technology is used.
	\item And the development of a Dapp that uses well-known DeFi protocols ~\ref{ch:defi}, to let users access to permissionless financial services such as lending and borrowing of crypto assets.
\end{itemize}


\section{Thesis Structure}
The Thesis is divided into the following chapters:
\begin{itemize}
	
	\item \textbf{Chapter ~\ref{ch:background} - Fundamentals}, gives a technical overwiev of the blockchain technology and the Ethereum network.
	\item \textbf{Chapter ~\ref{ch:defi}} ...
	\item \textbf{Chapter ~\ref{ch:appreq}} ...
	\item \textbf{Chapter ~\ref{ch:impl}} ...
	\item \textbf{Chapter ~\ref{ch:conclusion}} ...
\end{itemize}


%%%%%
%%%%% Chapter
\chapter{Fundamentals} \label{ch:background}

\section{Blockchain} \label{sec:bc}
A blockchain\cite{book:bc}\cite{article:bc} is a type of database (append-only data strucuture), which stores data in blocks. These blocks are chronologically ordered by discrete timestamps and linked to each other using cryptographic hash functions\cite{chf}\cite{book:chf}. Commonly, a blockchain is used as a public distributed ledger of transactions records, shared and synchronized by a per-to-per network~\ref{subsec:p2p}, where every party can participate in the validation of new blocks based on a consensus protocol, see~\ref{sec:cp}.
The idea of a cryptographically secured chain of blocks was originally presented by Haber and Stornetta\cite{time-stamp} in 1991. However, the implementation and adoption of this technology started with the conception of the bitcoin cryptocurrency whitepaper\cite{bitcoin} in 2008.

\begin{figure}[htp]
	\centering
	\includegraphics[width=1\textwidth]{./images/bc}
	\caption{View of two blocks in a blockchain}
	\label{fig:bc}
\end{figure}

Determined by the blockchain implementation, block contents can be different. A block usually has a timestamp, the data or transactions record, and the hash value of the previous block in the chain, see figure~\ref{fig:bc}.
The way that a blockchain ensures the security and keeps the integrity of the data is through cryptographic hash functions \ref{sec:chf}, and Merkle trees \ref{sec:mt}

By adding the cryptographic hash value of the previous block  (Block $n$ to Block $n+1$), blockchains ensure the integrity of previous blocks. Because of the second preimage resistance of cryptographic hash functions, see~\ref{sec:chf}, it is computationally infeasible to  find an input other then Block $n$ in order to generate an output = Hash (Block $n$). Due to that, the further the blockchain grows beyond block $n$, the more secure is the integrity of block $n$ and previous blocks.

Depending on who can participate in the consensus protocol, blockchain networks can be divided into two groups: permissionless and permissioned blockchains. This Thesis will be focused on permissionless blockchains that use an EVM, such as the Ethereum network.

\subsubsection{Peer-to-peer (P2P) network}\label{subsec:p2p}
\begin{figure}[htp]
	\centering
	\includegraphics[width=0.45\textwidth]{./images/p2p}
	\caption{Peer-to-peer network\cite{wiki:Peer-to-peer}}
	\label{fig:p2p}
\end{figure}
A peer-to-peer network\cite{book:masteringBTCp2p}\cite{wiki:Peer-to-peer} is a decentralized communications model where each participant (node) of the network stores and shares data with other nodes without any central party. Every peer is equal and there is no special node. Due to the decentralized design, P2P networks are resilient and robust compared with typical client-server architecture. The distributed ledger or blockchain is managed by the peer-to-peer network based on a set of rules or consensus mechanisms~\ref{sec:cp}, in fact, the term \emph{blockchain network} refers to a set of nodes, of a peer-to-peer network, running the consensus protocol of the specific blockchain. 



\subsection{Cryptographic hash functions}\label{sec:chf}
A cryptographic hash function\cite{chf}\cite{book:chf} maps a given data of variable size to a fixed length \emph{n}-bit string called hash value. $ H : \{0,1\}^* \to \{0,1\}^n $ Such hash functions have the following properties:
\begin{description}		
	\item \textbf{Collision resistance}\\ Given $x_1, x_2 $ It should be necessary $ O(2^\frac{n}{2}) $ compute power such that $H(x_1) = H(x_2).$This means, that it will be computationally infeasible that different inputs, i.e., blocks of data, will generate the same hash value.	
	\item \textbf{Preimage resistance}\\ For a hash value \emph{h}, it should be necessary $ O(2^n) $ computation power in order to obtain an \emph{x} such that $ H(x)=h $.~~In other words, it should be a one-way function. 
	This means that it is computationally infeasible to retrieve the input data from its hash value. For instance, it is nearly impossible to get a private key from its public key.	
	\item \textbf{Second preimage resistance}\\ For an input $x_1$ and its hash value $h_1$, it should be necessary $ O(2^n) $ computation power in order to obtain a $x_2$ such that $H(x_2)=h_1.$ This means that for a given hash value, it is computationally infeasible to find another input, i.e., a block data input, that generates the same hash value. 	
\end{description}

Such properties prevent attackers from modifying existing blocks keeping the blockchain intact. For example, the bitcoin network uses the SHA-256 hashing algorithm to validate a block, and append it to the chain. This means once a consensus among all the participants is done, and a new block is added, it will be required $ O(2^{256}) $ computation power to tamper with the blockchain. In other words, it is nearly impossible to manipulate an added block as a result of the tremendous computer power that would be needed.

\subsection{Merkle tree}\label{sec:mt}
A Merkle tree\cite{article:merkle}\cite{book:merkle} or hash tree is a binary tree where every leaf node (nodes at the bottom of the tree) is the cryptographic hash value of some data or transaction. A merkle tree is constructed bottom-up; the upwards nodes are the cryptographic hash values of its two child nodes. Therefore, the root node  will contain a complete fingerprint of the entire set of transactions. 

Merkle trees allow secure and efficient data verification using cryptographic hash functions. For example; if a participant in the network needs to verify the validity of these four transactions, see figure~\ref{fig:merkle}, only a check of the root hash value is necessary. Due to the Merkle tree structure, if any of the data blocks is modified, so will be the root hash value. Furthermore, Merkle tree is a very efficient data structure; for instance, checking that a given transaction is included in the tree will take a maximum of $2log (N)$ operations.
\begin{figure}[htp]
	\centering
	\includegraphics[width=0.65\textwidth]{./images/merkle}
	\caption{Merkle tree of four transactions}
	\label{fig:merkle}
\end{figure}
\subsection{Consensus Protocol}\label{sec:cp}
The consensus protocol\cite{article:bc} of a blockchain network gives a specific rule for verifying whether a transaction is valid or not. As mentioned in~\ref{sec:bc}, any participant or node of the network, depending on the blockchain type, can append a new block. For the reason that blockchains typically do not have a centralized authority validating transactions, participants on the blockchain must verify any transaction according to the set of rules or consensus protocol of the blockchain. The most common consensus mechanisms nowadays are:
\begin{description}		
	\item \textbf{Proof of work (PoW)}\\	In a PoW blockchain, nodes have to solve a cryptographic task in order to validate a block, the first node to find a solution can submit the transaction. Most of the first blockchains in the space use proof-of-work-based protocols; for example, Bitcoin uses PoW based on the cryptographic hash function SHA-256.
	\item \textbf{Proof of state (PoS)}\\	In a PoS blockchain, the entity that can validate a transaction is randomly selected, depending on the "stake" that a node has on the network. Since nodes have a large stake in the blockchain, they will pursue the integrity of the network. 	
\end{description}

\subsection{Public-Key Cryptography}\label{publickey}
In order to interact with a blockchain, participants use public key cryptography or asymmetric key cryptography\cite{book:pkc}. The public key acts as the id of the sender or receiver of a given message; and it can be shared with others without any security downfall. On the other hand, the private key should be kept secure and private by the message sender; it is used to sign (digital signature) the messages or transactions, i.e., give permission to change the state of the user records in the blockchain.
\begin{itemize}
	\item[] \textbf{Digital signature:} The message or transaction can only be signed with a private key, and anyone who knows the public key of the signed message can verify  its authenticity. Meaning that any party of the blockchain can participate in the verification of the transactions/messages.
\end{itemize}
The private key is a random number and the public key is generated from it using one-way cryptographic hash functions, see \ref{sec:chf} or elliptic curve cryptography\cite{book:pkc}\cite{wiki:ecc}. Elliptic curve cryptography (ECC) is based on the discrete logarithm problem and is the most common public-key algorithm in blockchain networks.
In mathematics terms, an elliptic curve is a plane curve over all the points $(x, y)$ that satisfy the following equation:  $ y^2 = x^3 +ax + b $

%\subsection{Bitcoin}
%The bitcoin network is a set of technologies that enabled for the first time a %decentralized, permissionless, trustless, peer-to-peer digital currency system. %The distributed computation system that bitcoin introduced: the proof-of-work %algorithm to produce a consensus in a distributed system without a central %trusted authority, in combination with the blockchain storage system, solved the %double-spend problem and the Byzantine generals problem.

\section{Ethereum}\label{sec:eth}
The Bitcoin\cite{bitcoin}\cite{book:masteringBTC} network and its set of technologies enabled for the first time a decentralized, permissionless, trustless, peer-to-peer digital currency system. The distributed computation system that bitcoin introduced: a proof-of-work algorithm to produce a consensus in a distributed system without a central trusted authority, in combination with the blockchain storage system, solved the double-spend problem and the Byzantine generals problem, enabling other applicability beyond digital currencies.  In 2014, Vitalik Butering introduced Ethereum\cite{article:eth}, a platform that moved beyond cryptocurrency applications.

Similar to Bitcoin, Ethereum\cite{article:eth}\cite{book:masteringETH} is a distributed transaction-based state machine. However, it is not only a cryptocurrency system. Ethereum is a decentralized computing platform or a decentralized, pseudo-turning complete virtual machine, which runs smart contracts and stores its state changes in its blockchain. Like bitcoin, state changes in ethereum are managed by a consensus mechanism, where everyone can participate in the validation of  blocks or state changes.

\subsection{Accounts}\label{sec:accounts}
Ethereum\cite{article:eth}\cite{wood2014ethereum} has an account-based model, where every account represents a state. An account is mapped with a 160 bits address (public key) and there are two types of accounts: \textit{Externally owned account} (EOA), controlled by a private key and (smart) \textit{contract account}, controlled by EVM code. Depending on the account type, an account state is represented by the following four fields: \textbf{Nonce} is a counter that represents the number of transactions or contracts created by the account. \textbf{Balance} is the amount of Ether owned by the account, expressed in Wei~\ref{tab:Ether_metrics}. \textbf{Storage hash} is the root hash of a merkle tree that represents the contents of the account. \textbf{Code hash} is the hash that points to the EVM code that the account has.
\begin{figure}[htp]
	\centering
	\includegraphics[width=0.8\textwidth]{./images/accounts}
	\caption{Ethereum Accounts\cite{evm-illustrate}}
	\label{fig:accounts}
\end{figure}

\subsubsection{Transactions and Messages}
A \textbf{transaction} is a cryptographically-signed message that can only be sent by an EOA. Transactions can trigger a state change on the blockchain or the execution of EVM code. Transactions can be divided into two groups:
\begin{itemize}
	\item  \textbf{Message calls}: The transactions between accounts.
	\item \textbf{Contract creations}: creation of a new account with EVM code in its data/code field.
\end{itemize}
\textbf{Messages} can be seen as internal transactions between contracts triggered by a message call. A message is like a transaction but produced by a contract. This way messages enable contracts to interact between them.
\subsection{Ethereum Virtual Machine (EVM)}\label{sec:evm}
The EVM\cite{wood2014ethereum}\cite{book:masteringETH-evm} is a quasi-Turing-complete machine; the quasi means that its computation is limited by the available \textbf{gas}~\ref{sec:gas} that the executed contract bytecode has, preventing that accidentally or malicious contracts execute forever. Thus, denial-of-service attacks are not possible on Ethereum. The EVM is a stack machine with 1024 elements. It is big-endian by design with 256-bit word size, which facilitates hashing and elliptic curve operations (Keccak-256 hashes and secp256k1 signatures). In addition to the {\textbf{Stack}}, the machine has two more  spaces where operations can access and store data: {\textbf{Memory}}; volatile and initialized to zero. \textbf{Account storage}; non-volatile and maintained as part of the Ethereum state, also initialized to zero. Lastly, the EVM code is stored in a separate virtual read-only memory (\textbf{ROM}).
\begin{figure}[htp]
	\centering
	\includegraphics[width=0.65\textwidth]{./images/evm}
	\caption{Ethereum Virtual Machine\cite{evm-illustrate}}
	\label{fig:accounts}
\end{figure}
\subsubsection{Ether and Gas}\label{sec:gas}
Ether (ETH) is the native cryptocurrency of Ethereum. Ether is used to pay for transaction fees or EVM computing power in the form of gas units. For example, the cost or gas limit for sending a transaction is 21000 gas units\cite{wood2014ethereum-Fee}. The price for a gas unit is represented in gwei, and is set by the participants of the consensus protocol (miners), based on the supply and demand of the network computational power\cite{book:masteringETH-gas}.
For instance, with an average gas price of 15 gwei\cite{gastracker}, sending a transaction at the moment of writing this Thesis would cost: $21000*15 = 315000~Gwei$ or $0.000315~Ether.$
\begin{table}[htp]
\centering
%\begin{center}
\begin{tabular}{|l|l|l|}
	\hline
	\multicolumn{1}{|c|}{\textbf{Unit Name}} & 
	\multicolumn{1}{|c|}{\textbf{Wei Value}} \\\hline
	$Ether$ & $1^{18}$  \\\hline
	$Gwei$  & $1^{9}$  \\\hline
	$Wei$   & $1$     \\\hline   
\end{tabular}
\caption{Important metrics of $Ether$}
\label{tab:Ether_metrics}
%\end{center}
\end{table}

\subsection{Smart Contracts}\label{sec:sc}
In the Ethereum network, a smart contract\cite{book:masteringETH-sc-solidity}\cite{smartcontracts} is a computer program that is executed by the EVM. Since smart contacts are also a type of account, see~\ref{sec:accounts}, they have a balance and can send transactions in the form of messages. Furthermore, smart contracts have the following properties:
\setdescription{font=\normalfont}
\begin{description}[style=nextline] %% Style for this list only.
	\item[{\textbf{Immutability}}] When a smart contract is deployed to the Ethereum platform, the code can not be changed. If a modification (fixing a bug or adding new functionality) needs to be made, a new smart contract needs to be deployed.
	\item[{\textbf{Determinism}}] Given an input and the blockchain state, the result of the execution of the smart contract has to be the same for everyone who calls the contract.
	\item[{\textbf{Limitations}}] By design, smart contracts can not send $HTTP$ requests; this can be solved using decentralized oracles\cite{oracles}. Furthermore, the context of execution is limited to the EVM, meaning that they can only access their own state and the transaction context of the transaction caller. Lastly, smart contracts can not exceed the size of $24KB$.
	\item[{\textbf{Lifecycle}}] Once deployed, smart contracts can no be modified. However, they can be deleted if the smart contract was programed with the \verb|selfdestruct()| function.
	\item[{\textbf{Composability}}] Since smart contracts can call other smart contracts, functionality of different contracts can be combined. However, such interaction between contracts has to be triggered by a transaction sent by an EOA.
	\item[{\textbf{Permissionless}}] Anyone can deploy a smart contract to the Ethereum network.    
\end{description}
Smart contracts can be written in EVM bytecode\cite{evmbytecode}. However, they are usually written in high-level programming languages such as \textit{Solidity}, \textit{Vyper}\cite{vyper} and \textit{Fe}\cite{fe}, among others, being Solidity, the most widely used programming language for smart contracts in EVM-based blockchains.
\subsubsection{Solidity}
{Solidity}\cite{book:masteringETH-sc-solidity}\cite{solidity} is an object-oriented or contract-oriented high-level programming language; it was created by Dr Gavin Wood and designed to target the EVM.  The Solidity compiler $solc$ converts Solidity contracts into EVM bytecode and also generates the contract application binary interface (ABI)\cite{abi}, which enables the interaction with contracts in both directions; from outside the blockchain and from contract to contract.
 
\subsection{Tokens}\label{sec:tokens}
Tokens have a widely used description\cite{wiki:Token}, in the context of Ethereum; a token\cite{tokens} is a digital representation or abstraction of something that lives on the Blockchain. For instance, tokens can represent currencies, shares in a company, or even a virtual pet. Unlike Ether, which is managed by the Ethereum protocol, tokens are created and handled by smart contracts. Everyone can create a token. Nonetheless, because a smart contract can be programed without any restriction, there are standards that need to be followed for the creation of tokens. The two most used standards are:
\begin{itemize}
	\item The \textbf{ERC20} Token Standard\cite{erc20}, for the representation of equivalent and interchangeable tokens (fungible tokens). For instance, a token that represents a currency or a share in a company. As defined in the EIP\cite{erc20}, the ERC20 contract is composed of the following elements:
	\begin{table}[htp]
		\centering
		%\begin{center}
		\begin{tabular}{|l|l|l|}
			\hline
			\multicolumn{1}{|c|}{\textbf{~Must have methods~~~}} & 
			\multicolumn{1}{|c|}{\textbf{~Optional methods~~~}}  &
			\multicolumn{1}{|c|}{\textbf{~Must have events~~~}} \\\hline
			$~\verb|totalSupply()|$& $~\verb|name()|$  & $~\verb|Transfer()|$  \\
			$~\verb|balanceOf()|$& $~\verb|symbol()|$ & $~\verb|Approval()|$  \\
			$~\verb|transfer()|$& $~\verb|decimals()|$  &  \\
			$~\verb|transferFrom()|$&  &   \\
			$~\verb|approve()|$&  &   \\
			$~\verb|allowance()|$&  &   \\\hline		 
		\end{tabular}
		\caption{Components of the ERC20 Standard.}
		\label{tab:erc20}
		%\end{center}
	\end{table}
	\item The \textbf{ERC721} Token Standard\cite{erc721}, for non-fungible tokens or representation of unique goods like an ID or collectibles.
\end{itemize}
\subsection{Decentralized Applications (Dapps)}\label{sec:dapps}
Unlike a web application, a decentralized application or Dapp\cite{book:dapps}\cite{dapps}\cite{dapps_arch} has its backend running on a decentralized per-to-per network such as Ethereum. For dapps running in an EVM-based blockchain, the backend is smart contracts executed by the EVM. This means that a dapp has the same properties as smart contracts and the blockchain network where it lives.
\subsubsection{Dapp architecture}\label{dapp}
The architecture of dapp is still been defined and depends, like any application, on the services that the application should provide. However, there are some main components that a dapp should have: 
\begin{figure}[htp]
	\centering
	\includegraphics[width=0.52\textwidth]{./images/dapp}
	\caption{Basic Dapp Architecture.}
	\label{fig:dappcomponents}
\end{figure}
\begin{description}		
	\item \textbf{Frontend}: It enables the users to interact with the smart contracts through interactive graphical components such as buttons, and icons, among others. Like web applications, this user interface runs on any browser.
	\item \textbf{Wallet}: A wallet is a tool or software application that manages the account's private key and addresses (public keys). Wallets don't have custody of the account crypto assets. A wallet is only an application that enables the account owner to sign transactions, therefore, interact with the blockchain and the smart contracts living in the network.
	\item \textbf{Node or Node Provider}: Enables communication with the blockchain i.e. reading data or sending transactions. A node will broadcast the transactions and miners will validate the new states that the transactions can produce. Everyone can run a node. Nonetheless, because of the difficulty and costs that running a node could have, Dapps usually rely on a third-party service or Node provider. Every Ethereum client or Node provider implements a JSON-RPC\cite{json_rpc} Specification with a uniform set of methods.
	\item \textbf{The Blockchain Network}: With the smart contracts that the application will use, the EVM that runs these smart contracts, and the blockchain that stores the states and data produced by the execution of these smart contracts.
\end{description}
Furthermore, the Comunication with the Node provider is done using web3 libraries such as ethers.js\cite{ethersjs} or web3.py\cite{web3py}.
%%%%% Chapter
\chapter{Decentralized Finance (DeFi)} \label{ch:defi}
Decentralized finance or DeFi\cite{article:cefidefi}\cite{article:defi} refers to a set of decentralized applications and protocols that are focused on financial services. The term finance\cite{wiki:Finance} involves the creation, and management of money, in traditional finance systems this is done by financial institutions\cite{wiki:Financial_institution}, which emit, buy and sell financial instruments\cite{wiki:Financial_instrument} on financial markets\cite{wiki:Financial_market}, all regulated by Laws. In DeFi,  these practices and processes are determined by protocols that rely on smart contracts, which means Defi is an open, permissionless, and composable stack of protocols built on top of a permissionless blockchain such as Ethereum~\ref{sec:eth}. 
\begin{figure}[htp]
	\centering
	\includegraphics[width=1\textwidth]{./images/tvl}
	\caption{Total Value Locked (USD)\cite{defipulse}}
	\label{fig:tvl}
\end{figure}

DeFi offers a wide variety of financial services. For example lending and borrowing of crypto-assets, exchange of crypto assets, stable currencies, and investments oportunities, among others. Unlike traditional financial systems, is open to anyone who has internet access, users have total control of their assets and Markets are always open. Furthermore, DeFi has gained a lot of traction in the past years and according to Defipulse\cite{defipulse}, at the moment of writing this Thesis, the total locked value or TVL (held by smart contracts) in all the DeFi applications and protocols is \$58.56B~\ref{fig:tvl}, being the Maker Protocol~\ref{sec:maker}, the Aave Protocol~\ref{sec:aave}, adn he Uniswap Exchange\cite{uniswap}, the three relevant DeFi protocols of the space with $\$14.52$B, $\$8.38$B and $\$7.04$B of TVL respectively. 
\section{Maker Protocol}\label{sec:maker}
One essential piece of DeFi is stable coins or stable cryptocurrencies, and DAI~\ref{sec:dai}  is one of the most popular stable coins in the space with a market cap of \$6.5B\cite{stablecoinsmarket} at the moment of writing. Stable coins are cryptocurrencies pegged to a predetermined value, usually to the USD value. It enables DeFi users to access more traditional assets, avoiding the natural volatility of crypto assets at the current moment. In addition, due to the high demand for stable coins in the DeFi space, users can also earn interest on their stablecoins by providing liquidity into lending pools of different protocols such as Aave~\ref{sec:aave} or Compound\cite{compound}.

The Maker Protocol\cite{maker} is an open-source project built on Ethereum that enables users to generate the stable coin Dai~\ref{sec:dai}. Wich is collateral backed by different crypto assets authorized by the MakerDao, a decentralized autonomous organization (DAO)\cite{wiki:Dao}, made up of all the Maker governance token (MKR) holders. The MKR token is an ERC20 token~\ref{sec:tokens} that enables dao participants to vote on different changes or improvements to the Maker protocol.
\subsection{DAI}\label{sec:dai}
DAI\cite{makerDAI} is the main product of the Maker Protocol. DAI is an ERC20 token~\ref{sec:tokens},  pegged to the USD value and fully backed by different crypto assets, approved by the MakerDao, such as ETH~\ref{sec:gas}. DAI can be generated by depositing any accepted collateral crypto asset into the Maker Vaults. In short, the Maker Vaults are a set of smart contracts~\ref{sec:sc} that lock the deposited asset and generate DAI (let the user borrow DAI). The generated DAI is destroyed by the vault when the generated DAI is repaid to the Vault. Vaults are overcollateralized, for instance, at the time of writing, the Maker ETH-C Vault has a minimum collateral ratio of 170\%\cite{oasisapp}, meaning that for every \$170 of ETH deposit in the Vault a maximum of 100 DAI can be generated.
\section{Aave Protocol}\label{sec:aave}
Aave\cite{aaveV1}\cite{aaveV2}\cite{aaveV3} is a DeFi liquidity protocol that enables users to lend and borrow crypto assets. Aave was first deployed on the Ethereum network, however, at the moment of writing, Aave has expanded to other EVM-based blockchain and Layer 2 scaling solutions such as  Polygon\cite{polygon}, Avalanche\cite{avax}, Fanton\cite{fanton}, and Arbitrum\cite{arbitrum}, among many others.

Using Aave, users that supply liquidity to the protocol (lenders) earn interest on their deposited assets, and borrowers are able to borrow crypto assets after depositing collateral to the pool contract. The interest rate for users (borrowers and lenders) is decided algorithmically based on the reserves available in the pool. The \textbf{reserves}, see fig~\ref{fig:pool}, are the multiple currencies deposited on the pool expressed in ETH value and defined as \textit{total liquidity}. Lenders can deposit into these reserves to earn interests and Borrowers can borrow from the reserves after making a deposit, locking a greater value as collateral for the borrowed funds. Only specific low-risk crypto assets are configured as collateral.\label{reserve}  

\begin{figure}[htp]
	\centering
	\includegraphics[width=1\textwidth]{./images/lp_reserves}
	\caption{Pool Parameters\cite{aaveV1}}
	\label{fig:pool}
\end{figure}
\subsection{Aave Rates and Risk Parameters}\label{rates}
 As mentioned in the last paragraph, for lenders and borrowers the interest rate is determined by the status of the specific reserve. For \textbf{lenders}, the interest rate depends on  the \textit{current liquidity rate}:
\[ R_{t} = R_{o}U \]
Where $ R_{o} $ is the overall borrow rate of the reserve defined as follows:
\begin{equation}
	R_{o} = 
	\left\{\begin{matrix}
		&  0~~if~~B_{t}=0\\ 
		& \frac{B_{v}R_{v}+ B_{s}R_{sa}}{B_{t}}~~if~~B_{t} > 0
	\end{matrix}\right.
\end{equation}
With the total amount of borrowed liquidity $B_{t} $ (\textit{total borrows}), expressed as the sum of the total stable borrows plus  the total variable borrows :
\[ B_{t} = B_{s}+B_{v} \]
And $ U $ is the \textit{utilization rate}, wich is the representation of the utilization of the deposited assets, defined as follows:
\begin{equation}
	U = 
	\left\{\begin{matrix}
		&  0~~if~~L_{t}=0\\ 
		& \frac{B_{t}}{L_{t}}~~if~~L_{t} > 0
	\end{matrix}\right.
\end{equation}
Where $L_{t}$  is the \textit{total liquidity} available in the reserve.

\textbf{Borrowers} can borrow crypto assets with variable and stable interest rates. 
The $R_{v}$\cite{aaveV1RV} is the \textit{variable borrow rate} and $R_{sa}$\cite{aaveV1RS} is the \textit{average stable rate}. \\

Note that the mentioned definitions are from the V1\cite{aaveV1} whitepaper hold for the V2\cite{aaveV2} and the recently V3\cite{aaveV3} release.

\subsubsection{Loan-To-Value (LTV)} 
A user will be able to borrow a maximum amount depending on the Loan-To-Value (LTV)\cite{aaveV1}\cite{risk} of the desired asset reserve. For instance, if the LTV value of a given asset is  60\%, see fig~\ref{fig:pool}, for every 1 ETH value of collateral deposited, a user can borrow a maximum of 0.6 ETH value of the desired asset reserve. The max LTV is defined as follows:\[ maxLTV = \frac{\sum Collateral_{i}~ETH~\times LTV_{i}}{Total~Collateral~in~ETH} \]
\subsubsection{Liquidations}\cite{aaveV1}\cite{liquidation} 
To maintain the solvency of the protocol, anyone can liquidate a borrow position i.e. buy a maximum of 50\% of the borrow position. Every liquidated position has a liquidation bonus, which depends on the asset. For instance, if someone borrows 1 ETH worth of DAI and its~$H_{f}$~\ref{hf} drops below 1, anyone can liquidate the position (max 50\%) for a bonus of 5\% (105\% liquidation ratio, see fig~\ref{fig:pool}) at the movement of writing, the liquidator can claim up to 0.5 + 0.05 ETH by repaying 0.5 ETH worth of DAI.
\subsubsection{Liquidation Threshold}
Because of price fluctuations in the market, a borrow position can become close to the collateral position. The percentage at which a borrow position can be liquidated is called the liquidation threshold\cite{aaveV1}\cite{risk} . For instance, if the liquidation threshold of a given asset is 80\% and the borrow position value surpasses 80\% of the collateral value, the position can be liquidated. The liquidation threshold is defined as follows:
\[ Liquidation~Threshold = \frac{\sum Collateral_{i}~in~ETH~\times Liquidation Threshold_{i}}{Total~Collateral~in~ETH} \]
The $Liquidation Threshold_{i}$ for a given asset is defined and approved by the aave governance~\ref{governance}.
\subsubsection{Health Factor}\label{hf}
In order to maintain solvency in the protocol, every user or account has a health factor\cite{aaveV1}\cite{risk} , which indicates if the borrow position of the user can be liquidated. If~$H_{f} < 1$ the borrow position can be liquidated.
\[ H_{f} = \frac{\sum Collateral_{i}~in~ETH~\times Liquidation Threshold_{i}}{Total~Borrows~in~ETH} \]

\subsubsection{\textit{Ray Math}}\label{ray}
In order to avoid rounding errors, the aave protocol uses Ray Math\cite{ray}\cite{ray2}, where a Ray is a unit with 27 decimals of precision. All the rates are expressed in Ray.
\subsection{Tokenization: aTokens}\label{atokens}
Aave Tokens or aTokens\cite{aaveV1aToken} are ERC20 tokens~\ref{sec:tokens} that a liquidity provider of the protocol (lenders or depositors) receives once the deposit transaction is processed, aTokens maps 1:1 the deposited asset also known as the underlying asset. For instance, if a user deposits 100 DAI, 100 aDAI is sent to its account~\ref{sec:accounts}. The balance of a specif aTokens grows depending on the interest rate~\ref{rates} of the underlying asset. 
\subsection{Lending Pool}
At the heart of the Aave protocol is the \verb|lendingPool.sol| or \verb|pool.sol|, renamed in the V3\cite{aaveV3} release. The pool handles the most important actions of the protocol. Users and developers can interact with the pool contract to deposit, borrow, and repay a borrow position, among other actions, see fig~\ref{fig:pool_arch}. 
\begin{figure}[htp]
	\centering
	\includegraphics[width=1\textwidth]{./images/pool_arch}
	\caption{Aave V2 Protocol Architecture\cite{aaveV2}}
	\label{fig:pool_arch}
\end{figure}
\subsection{Aave Governance}\label{governance}
Aave\cite{aaveV1GOV} uses a decentralized autonomous organization or DAO\cite{wiki:Dao} to govern the protocol. The General Governance Process\cite{gov} at the time of writing is executed as follows:
\begin{enumerate}
	\item \textbf{Governance Forum\cite{govForum}:} The proposals are introduced. Anyone can create an Aave Request for Comments (ARC)\cite{arc} and submit it to the forum.
	\item \textbf{Snapshot\cite{snapshot}:} The ACR is submitted to vote.
	\item \textbf{AIP:} If the proposal passes the snapshot, it moves to the Aave Improvement Proposal (AIP), which is reviewed by devs, and risk/security contributors, before any on-chain submission.
	\item \textbf{Create Proposal:} When the AIP has been revised, it can be created on-chain. A user with enough proposition power can call the function \verb|create()|\cite{create} from the aave governance contract.
	\item \textbf{Voting and Execution:} This will result in the proposal being succeeded or failed. If succeeded the proposal can be executed or expired.
\end{enumerate}

%%%%% Chapter
\chapter{Application Requirements} \label{ch:appreq}
This Chapter describes the application requirements based on ISO/IEC/IEEE 29148:2018\cite{iso} Software Requirements Specification standard.

\textbf{Project}: Thesis.
\section{Introduction}
\subsection{Purpose}
The main purpose of this Chapter is to provide a detailed description of the Decentralized application developed for this Thesis. 
\subsection{Scope}
Requirements for a decentralized application that can provide
permissionless financial services using an evm based blockchain.

The minimum viable functionality that the application shall offer the users are:
\begin{itemize}
	\item Sign in with the metamask wallet.
	\item See which tokens can be deposited.
	\item Using Aave: Deposit ETH, DAI to earn interest. 
	\item Using Aave: Withdrawal of deposited assets.
	\item Using Aave: Borrow DAI.
	\item Using Aave: Repay the borrowed DAI.
\end{itemize}
The application runs online; its frontend may not be decentralized, but its backend runs on top of an EVM-based blockchain such as Ethereum.
\subsection{Product Perspective}
\subsubsection{Interface}
The application runs in the latest version of Chrome, Firefox, Brave browsers on Windows, Linux and Mac.

\section{Requirements}
\subsection{Functional}
\subsubsection{Login}
[Thesis-SRS-01] The application shall allow users to login using the Metamask\cite{wiki:MetaMask} wallet.

[Thesis-SRS-02]  If the wallet is set with another network, the application should inform the user to change to the application network.

[Thesis-SRS-03] The application shall display the user balance of the supported assets.

[Thesis-SRS-04] The application shall display the user balance of deposit assets and earnings.

[Thesis-SRS-05] The application shall display the interest rates for the supported assets.
\subsubsection{Deposit}
[Thesis-SRS-06] The application shall allow users to deposit ETH to earn interest.

[Thesis-SRS-07] The application shall allow users to deposit DAI to earn interest.

[Thesis-SRS-08] The application shall convert ETH to WETH, because the protocol only accepts ETH in the form of ERC20, i.e. WETH.

[Thesis-SRS-09] The application shall display the user's balance after any deposit transaction.

\subsubsection{Withdrawal}
[Thesis-SRS-10] The application shall allow users to withdraw deposited cryptoassets.

[Thesis-SRS-11] The application shall display the user's balance after any withdrawal transaction.

[Thesis-SRS-12] The application shall display the user's balance after any withdrawal transaction.
\subsubsection{Borrow}
[Thesis-SRS-13] The application shall set the maximum borrowable DAI at 90\%, to avoid liquidations and display it.

[Thesis-SRS-14] The application shall let users borrow DAI based on users' deposited collateral.

[Thesis-SRS-15] The application shall let users repay their partial or total borrowed DAI. 

[Thesis-SRS-16]The application shall display the user's balance after any borrow transaction.
\subsubsection{Repay}
[Thesis-SRS-17] The application shall let users repay their partial or total borrowed DAI 

[Thesis-SRS-18] The application shall display the user's balance after any repay transaction.
\subsection{Nonfunctional}

[Thesis-SRS-19] The application should display a notification after any deposit transaction.

[Thesis-SRS-20] The application should display a notification after any withdrawal transaction.

[Thesis-SRS-21] The application should display a notification after any borrow transaction.

[Thesis-SRS-22] The application should display a notification after any repay transaction.
\subsubsection{Performance}
[Thesis-SRS-23] The application will be deployed in the Ethereum Rinkeby test network.
\subsection{Use Case}
The following use case diagram describes the minimum functionality that the application shall have.
\begin{figure}[htp]
	\centering
	\includegraphics[width=0.89\textwidth]{./images/USECASE-full_nofl}
	\caption{Use Case Diagram: Minimum Viable Product.}
	\label{fig:usecase-mvp}
\end{figure}
\newpage
%If the development process goes well and there is enough time, the application should add %more functionalities as illustrated in the following use case diagram. The requirement %document/chapter\cite{ch:appreq} should also be updated.
%\begin{figure}[htp]
%	\centering
%	\includegraphics[width=0.97\textwidth]{./images/USECASE-full_nofl}
%	\caption{Use Case Diagram: Expected Application Functionality.}
%	\label{fig:usecase-mvp}
%\end{figure}
%%%%% Chapter
\chapter{Implementation} \label{ch:impl}
%\section{Defining the tech stack}
\section{Interaction with the Smart Contracts}
The main purpose of the application is to be able to access the different functionalities, such as deposit and borrow, of \verb|pool.sol|  smart contract within the Aave Protocol~\ref{sec:aave}. In order to test the interaction process with smart contracts, the Brownie framework\cite{brow} is been used. Brownie is a python framework for the development and testing of EVM smart contracts. Brownie enables developers the compilation, test, and deployment of smart contracts with just a few commands, it also uses the ganache-cli\cite{ganache}, which is a built-in local blockchain (test RPC blockchain node) hosted on $127.0.0.1:8545$ for fast contract tests. Brownie also lets developers manage accounts and network configurations in an easy and safe way. A new brownie project for this Thesis was created using the \verb|brownie init| command.

In accordance with its permissionless characteristic, anyone can interact with a smart contract. However, from a developer perspective, to be able to interact with a smart contract the following three items are needed:
\begin{enumerate}\label{sc_interaction}
	\item An Account: Needed to sign the transactions. Brownie provides developers with a set of test accounts. However, for this project, a new EOA Account~\ref{sec:accounts} was created using Metamask\cite{wiki:MetaMask}, and imported to the brownie project using its private key~\ref{publickey}.
	\item The Application Binary Interface (ABI)~\ref{sec:sc}, which is generated in the compilation process, \verb|brownie compile| command.
	\item The Smart Contract Address: This is the address of the contract account~\ref{sec:accounts}. 
\end{enumerate}
This Thesis uses the smart contracts from the V3 release of the Aave Protocol. All the contracts are open source and can be found in the Aave GitHub repository\cite{aavegithub}. Since all the contracts are also deployed in different EVM blockchains, the contracts can also be found in their respective blockchains explorers. For instance the \verb|pool.sol| deployment in the Arbitrum Network can be found here\cite{arbiscan}.

The following figure~\ref{fig:interactionSC} gives an overview of how the account and the  smart contracts (used for this Thesis) interact with each other:
\begin{figure}[htp]
	\centering
	\includegraphics[width=\textwidth]{./images/interactionSC}
	\caption{Smart contract interactions for the project of this thesis.}
	\label{fig:interactionSC}
\end{figure}
\subsection{The Pool Contract}
The \verb|pool.sol|\cite{poolContract} contract enables users and other contracts to interact with the main functionality of the Aave Protocol. More specifically, the \verb|IPool.sol|, which is the interface of the \verb|pool.sol|. The \verb|IPool.sol| is placed on top of the pool.sol (inherit) and contains the functions declarations that the \verb|pool.sol| shall implement. Functions in the \verb|IPool.sol| are declared using the keyword \verb|external|, enabling other contracts the interaction with these functions. This interface construction facilitates the interaction between Dapps or contracts. The functions of the pool.sol used for this Thesis is: 
\begin{itemize}
	\item{\textbf{Supply:}} The \verb|supply()| function, also known as the deposit function in Aavve V1 and V2, enables accounts to deposit a given amount of a supported crypto asset into its reserve~\ref{reserve}. If the supply transaction success, the account address, set in the parameter \verb|onBehalOf|, will receive the equivalent amount of aTokens. For instance, if an account supplies $100$ DAI, $100$ aDAI will be sent back to the account address set in the \verb|onBehalOf| parameter. Once the supply transaction is done, interest~\ref{rates} is generated according to the status of the reserve of the deposited crypto asset.
	\item{\textbf{Withdraw:}} The \verb|withdraw()| function enables accounts to get the deposited asset ( underlying asset ) from the reserve by destroying or burning the generated aToken for the deposited asset. Only accounts holding the aToken will be allowed to withdraw the underlying asset from the reserve. The caller of the withdraw function can decide the receiver of the underlying asset by passing the desired account address to the parameter \verb|to|.
	\item{\textbf{Borrow:}} This function allows accounts to borrow a maximum amount of a given asset depending on the borrowing power of the account. The borrowing power of the account depends on how much collateral the account has deposited into the collateral reserve. Borrowers can decide the interest rate by setting \verb|theinterestRateMode| parameter to stable or variable~\ref{rates}. The account address set in the \verb|onBehalfOf| parameter will receive the specif amount of debt tokens.
	\item{\textbf{Repay:}} The \verb|repay()| function allows accounts to pay back borrowed assets by burning the specific debt tokens, reducing or removing the debt tokens of the account address passed in the \verb|onBehalfOf| parameter. 	
\end{itemize}
\subsection{The Address Provider Contract}
As mentioned before~\ref{sc_interaction}, for interaction with smart contracts, the address of the contract account is needed. One of the characteristics of a smart contract is its immutability, once a contract is deployed to the blockchain network it can not be changed. However, with the purpose of being able to implement new features or improvements approved by the Aave Governance~\ref{governance}, the pool contract implements the Proxy Upgrade Pattern\cite{ozproxy}, based on \textit{delegatecall}\cite{delegatecall}, where the code is executed in the context of the caller account address. For this reason, to obtain the address of the pool contract, or IPool contract, the \verb|IPoolAddressesProvider.sol|\cite{pooladdrprov} contract is needed. This contract provides the function \verb|getPool()|, which returns the address of the pool proxy contract.
\subsection{The IERC20 Contract}
Since ERC20 follows a standard~\ref{sec:tokens}, the \verb|IERC20.sol| allow accounts to interact with any deployed ERC20 token. The project of this thesis needs to interact with ERC20 tokens, for instance, getting the balance of a given token or approving tokens to be deposited into the pool contract. Such actions can be accomplished by calling the \verb|balanceOf()| and \verb|approve()| functions.
\subsection{The IWETH Contract}
Because the pool contract can only handle ERC20 tokens, to be able to use ETH within the protocol, it needs to be converted to an ERC20 token. The \verb|IWETH.sol| allow accounts to wrap ETH into an ERC20 token. Accounts that call the \verb|deposit()| method of the IWETH contract will receive the exact amount of the deposited ETH in the form of WETH, which is an ER20 token that represents EHT. Accounts that desire to deposit ETH to the pool contract need first to convert their ETH to WETH. Another option, used in this project, is to use the \verb|IWETHGateway.sol|\cite{wethgateway} contract provided by Aave. This contract takes care of wrapping and unwrapping the deposited ETH.
\subsection{Node Provider}
As noted earlier~\ref{sec:dapps}, to communicate with the blockchain, more precisely to a node of the network, where the EVM and smart contracts live, a node or node provider service is needed. For this project, the Alchemy\cite{alchemy} and Infura\cite{infura} nodes were used. Both Services offer developers an endpoint (an API KEY) to communicate with the desired blockchain network, allowing developers to interact with the network without the need to run a node.
\subsubsection{Web3.py: Brownie}
To send transactions to the blockchain (interact with the smart contracts), a connection to the node provider is needed. This connection can be done using well-known web3 libraries such as \verb|web3.py|\cite{web3py}. For instance, using \verb|web3.py| the connection to the node provider can be done using the following code:\\
\verb|w3 = Web3(Web3.HTTPProvider(|

\hspace{1cm}\verb|'https://rinkeby.infura.io/v3/$WEB3_INFURA_PROJECT_ID')| \verb|)|

Where \verb|WEB3_INFURA_PROJECT_ID| is the APY KEY from the node provider. The \verb|w3| instance enables communication with the blockchain.\\
The brownie framework\cite{brow} wraps \verb|web3.py| and enables developers an easy and fast configuration of the targeted blockchain node. The configuration options are placed in the \verb|.env| and \verb|.yaml| files of the project. After the configuration is done, python scripts on the targeted network can be run, passing the network name on the \verb|–network| flag. For instance, running a python script that targets the rinkeby test network, can be done as follows:\\
\hspace{1cm}\verb| brownie run scripts/my_script.py --network rinkeby|\\
For instance, using brownie  and the Alchemy node provider, a python script that performs the deposit action, for a given amount of DAI, can be described as follows:
\begin{itemize}
	\item[]
	1.- Compile all the contracts to generate the ABIs.\\
	2.- Get the IPool address using the IPool address provider contract.\\
	3.- Using the IPool ABI and the IPool address, get the IPool contract object.\\
	4.- Using the IERC20 ABI and the IERC20 address, get the IERC20 object.\\
	5.- Get the DAI balance of the account using the IERC20 contract object.\\
	6.- If the desired amount to deposit is less than the account DAI balance, approve the desired amount using the IERC20 object, setting the \verb|spender| parameter to the address of the pool.\\
	7.- Call the \verb|supply()| function with the desired amount of DAI.
	
\end{itemize}
The first interaction with the smart contracts of Aave, for the application of this thesis, was done using the brownie framework. However, in order to let other accounts (users), interact with these smart contracts a frontend with a wallet~\ref{dapp} is needed.
\section{Interaction with the users}
To enable any EOA account (users), to interact with the smart contracts, a frontend and a wallet are needed. 
\subsection{Frontend: Next.js}
\subsubsection{Wallet: Metamask}
\subsubsection{Web3-react}
\subsection{Web3 Library: ethers.js}

%%%%%
%%%%% Chapter
\chapter{Conclusion and future work} \label{ch:conclusion}
\newpage

\bibliographystyle{plain} % Literaturverzeichnis
\begin{btSect}{thesis} % mit bibtopic Quellen trennen
\section*{Bibliography}
\btPrintCited
\end{btSect}
\begin{btSect}{online}
\section*{Online Sources}
\btPrintCited
\end{btSect}
% dann mit "bibtex thesis1" und "bibtex thesis2" arbeiten

\end{document}
;;; Local Variables:
;;; ispell-local-dictionary: "de_DE-neu"
;;; End:
