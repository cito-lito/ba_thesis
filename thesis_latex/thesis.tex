\documentclass[11pt,a4paper]{report} 
% Alternativ für doppelseitigen Ausdruck (nur bei > 60 Seiten sinnvoll)
% \documentclass[11pt,a4paper,twoside,openright]{report} 

\include{preamble} % alle Pakete und Einstellungen

% Hier anpassen 
\newcommand{\welchethesis}{Bachelor}
% \newcommand{\welchethesis}{Master}
\newcommand{\thesisofwas}{of Science - B.Sc.}
\newcommand{\titel}{Study and implementation of a decentralized application that can provide
	permissionless financial services using an evm based blockchain}
%\newcommand{\kurztitel}{Template Abschlussarbeit}
\newcommand{\autor}{Mario Alberto Maita Orozco}
\newcommand{\datum}{30.06.2022} % Abgabedatum
\newcommand{\ort}{Wiesbaden}
\newcommand{\referent}{Prof.\ Dr.\ Eva-Maria Iwer}
\newcommand{\korreferent}{Prof.\ Dr.\ Marc-Alexander Zschiegner}
%\usepackage{tabularx}
\usepackage{enumitem}
\usepackage{hyperref}
\hypersetup{
	colorlinks=true,
	linkcolor=blue,
	filecolor=magenta,      
	urlcolor=cyan,
	citecolor=blue,
%	pdftitle={Overleaf Example},
%	pdfpagemode=FullScreen,
}
\begin{document}
\include{vorspann} % Titelseite, Erklärungen, etc.

\begin{abstract} 
abstract
\end{abstract}

\tableofcontents
\newpage 

\chapter{Introduction} \label{ch:intro}
%\epigraphhead[70]{\epigraph{Documentation is like sex: 
%when it is good, it is very, very good; and when it is bad, 
%sit is better than nothing.}{\textit{Dick Brandon}}}



\section{Motivation}
In the last years' blockchain technology has gained a lot of traction and many developers are willing to build applications on top of this technology.
The Ethereum network with the Ethereum Virtual Machine, or EVM~\ref{sec:evm}, (whose state is validated and copied by every node of the network) offers a new way of application development. Meaning that developers can now implement some functionality and deploy it to a public EVM blockchain, making the code/functionality tamper-resistant; in addition, the implemented functionality (or smart contract) can be called by any participant or other code/contracts within the network. This composability allows anyone to interact with already deployed contracts and build other applications on top of them. 
These kinds of applications are called Decentralized applications or Dapps~\ref{sec:dapps}, because they are built on top of a decentralized network such as  Ethereum.
\section{Goals}
The goals of this Thesis are, to study and provide a better understanding of: 
\begin{itemize}
	\item How Dapps are built.
	\item Which technology is used.
	\item And the development of a Dapp that uses well-known DeFi protocols ~\ref{ch:defi}, to let users access to permissionless financial services such as lending and borrowing of crypto assets.
\end{itemize}


\section{Thesis Structure}
The Thesis is divided into the following chapters:
\begin{itemize}
	
	\item \textbf{Chapter ~\ref{ch:background} - Fundamentals}, gives a technical overwiev of the blockchain technology and the Ethereum network.
	\item \textbf{Chapter ~\ref{ch:defi}} ...
	\item \textbf{Chapter ~\ref{ch:appreq}} ...
	\item \textbf{Chapter ~\ref{ch:impl}} ...
	\item \textbf{Chapter ~\ref{ch:conclusion}} ...
\end{itemize}


%%%%%
%%%%% Chapter
\chapter{Fundamentals} \label{ch:background}

\section{Blockchain} \label{sec:bc}
A blockchain\cite{book:bc}\cite{article:bc} is a type of database (append-only data strucuture), which stores data in blocks. These blocks are chronologically ordered by discrete timestamps and linked to each other using cryptographic hash functions\cite{chf}\cite{book:chf}. Commonly, a blockchain is used as a public distributed ledger of transactions records, shared and synchronized by a per-to-per network, where every party can participate in the validation of new blocks based on a consensus protocol, see~\ref{sec:cp}.
The idea of a cryptographically secured chain of blocks was originally presented by Haber and Stornetta\cite{time-stamp} in 1991. However, the implementation and adoption of this technology started with the conception of the bitcoin cryptocurrency whitepaper\cite{bitcoin} in 2008.

\begin{figure}[htp]
	\centering
	\includegraphics[width=1\textwidth]{./images/bc}
	\caption{View of two blocks in a blockchain}
	\label{fig:bc}
\end{figure}

Determined by the blockchain implementation, block contents can be different. A block usually has a timestamp, the data or transactions record, and the hash value of the previous block in the chain, see figure~\ref{fig:bc}.
The way that a blockchain ensures the security and keeps the integrity of the data is through cryptographic hash functions \ref{sec:chf}, and Merkle trees \ref{sec:mt}

By adding the cryptographic hash value of the previous block  (Block $n$ to Block $n+1$), blockchains ensure the integrity of previous blocks. Because of the second preimage resistance of cryptographic hash functions, see~\ref{sec:chf}, it is computationally infeasible to  find an input other then Block $n$ in order to generate an output = Hash (Block $n$). Due to that, the further the blockchain grows beyond block $n$, the more secure is the integrity of block $n$ and previous blocks.

Depending on who can participate in the consensus protocol, blockchain networks can be divided into two groups: permissionless and permissioned blockchains. This Thesis will be focused on permissionless blockchains that use an EVM, such as the Ethereum network.



\subsection{Cryptographic hash functions}\label{sec:chf}
A cryptographic hash function\cite{chf}\cite{book:chf} maps a given data of variable size to a fixed length \emph{n}-bit string called hash value. $ H : \{0,1\}^* \to \{0,1\}^n $ Such hash functions have the following properties:
\begin{description}		
	\item \textbf{Collision resistance}: Given $x_1, x_2 $ It should be necessary $ O(2^\frac{n}{2}) $ compute power such that $H(x_1) = H(x_2).$This means, that it will be computationally infeasible that different inputs, i.e., blocks of data, will generate the same hash value.	
	\item \textbf{Preimage resistance}: For a hash value \emph{h}, it should be necessary $ O(2^n) $ computation power in order to obtain an \emph{x} such that $ H(x)=h $.~~In other words, it should be a one-way function. 
	This means that it is computationally infeasible to retrieve the input data from its hash value. For instance, it is nearly impossible to get a private key from its public key.	
	\item \textbf{Second preimage resistance}: For an input $x_1$ and its hash value $h_1$, it should be necessary $ O(2^n) $ computation power in order to obtain a $x_2$ such that $H(x_2)=h_1.$ This means that for a given hash value, it is computationally infeasible to find another input, i.e., a block data input, that generates the same hash value. 	
\end{description}

Such properties prevent attackers from modifying existing blocks keeping the blockchain intact. For example, the bitcoin network uses the SHA-256 hashing algorithm to validate a block, and append it to the chain. This means once a consensus among all the participants is done, and a new block is added, it will be required $ O(2^{256}) $ computation power to tamper with the blockchain. In other words, it is nearly impossible to manipulate an added block as a result of the tremendous computer power that would be needed.

\subsection{Merkle tree}\label{sec:mt}
A Merkle tree\cite{article:merkle}\cite{book:merkle} or hash tree is a binary tree where every leaf node (nodes at the bottom of the tree) is the cryptographic hash value of some data or transaction. A merkle tree is constructed bottom-up; the upwards nodes are the cryptographic hash values of its two child nodes. Therefore, the root node  will contain a complete fingerprint of the entire set of transactions. 

Merkle trees allow secure and efficient data verification using cryptographic hash functions. For example; if a participant in the network needs to verify the validity of these four transactions, see figure~\ref{fig:merkle}, only a check of the root hash value is necessary. Due to the Merkle tree structure, if any of the data blocks is modified, so will be the root hash value. Furthermore, Merkle tree is a very efficient data structure; for instance, checking that a given transaction is included in the tree will take a maximum of $2log (N)$ operations.
\begin{figure}[htp]
	\centering
	\includegraphics[width=0.65\textwidth]{./images/merkle}
	\caption{Merkle tree of four transactions}
	\label{fig:merkle}
\end{figure}
\subsection{Consensus Protocol}\label{sec:cp}
The consensus protocol\cite{article:bc} of a blockchain network gives a specific rule for verifying whether a transaction is valid or not. As mentioned in~\ref{sec:bc}, any participant or node of the network, depending on the blockchain type, can append a new block. For the reason that blockchains typically do not have a centralized authority validating transactions, participants on the blockchain must verify any transaction according to the set of rules or consensus protocol of the blockchain. The most common consensus mechanisms nowadays are:
\begin{itemize}
	\item[] \textbf{Proof of work (PoW)}
	In a PoW blockchain, nodes have to solve a cryptographic task in order to validate a block, the first node to find a solution can submit the transaction. Most of the first blockchains in the space use proof-of-work-based protocols; for example, Bitcoin uses PoW based on the cryptographic hash function SHA-256.	
	\item[] \textbf{Proof of state (PoS)}
	In a PoS blockchain, the entity that can validate a transaction is randomly selected, depending on the "stake" that a node has on the network. Since nodes have a large stake in the blockchain, they will pursue the integrity of the network.

\end{itemize}
\subsection{Public-Key Cryptography}
In order to interact with a blockchain, participants use public key cryptography or asymmetric key cryptography\cite{book:pkc}. The public key acts as the id of the sender or receiver of a given message; and it can be shared with others without any security downfall. On the other hand, the private key should be kept secure and private by the message sender; it is used to sign (digital signature) the messages or transactions, i.e., give permission to change the state of the user records in the blockchain.
\begin{itemize}
	\item[] \textbf{Digital signature:} The message or transaction can only be signed with a private key, and anyone who knows the public key of the signed message can verify  its authenticity. Meaning that any party of the blockchain can participate in the verification of the transactions/messages.
\end{itemize}
The private key is a random number and the public key is generated from it using one-way cryptographic hash functions, see \ref{sec:chf} or elliptic curve cryptography\cite{book:pkc}\cite{wiki:ecc}. Elliptic curve cryptography (ECC) is based on the discrete logarithm problem and is the most common public-key algorithm in blockchain networks.
In mathematics terms, an elliptic curve is a plane curve over all the points $(x, y)$ that satisfy the following equation:  $ y^2 = x^3 +ax + b $

%\subsection{Bitcoin}
%The bitcoin network is a set of technologies that enabled for the first time a %decentralized, permissionless, trustless, peer-to-peer digital currency system. %The distributed computation system that bitcoin introduced: the proof-of-work %algorithm to produce a consensus in a distributed system without a central %trusted authority, in combination with the blockchain storage system, solved the %double-spend problem and the Byzantine generals problem.

\section{Ethereum}
The Bitcoin\cite{bitcoin}\cite{book:masteringBTC} network and its set of technologies enabled for the first time a decentralized, permissionless, trustless, peer-to-peer digital currency system. The distributed computation system that bitcoin introduced: a proof-of-work algorithm to produce a consensus in a distributed system without a central trusted authority, in combination with the blockchain storage system, solved the double-spend problem and the Byzantine generals problem, enabling other applicability beyond digital currencies.  In 2014, Vitalik Butering introduced Ethereum\cite{article:eth}, a platform that moved beyond cryptocurrency applications.

Similar to Bitcoin, Ethereum\cite{article:eth}\cite{book:masteringETH} is a distributed transaction-based state machine. However, it is not only a cryptocurrency system. Ethereum is a decentralized computing platform or a decentralized, pseudo-turning complete virtual machine, which runs smart contracts and stores its state changes in its blockchain. Like bitcoin, state changes in ethereum are managed by a consensus mechanism, where everyone can participate in the validation of  blocks or state changes.

\subsection{Accounts}\label{sec:accounts}
Ethereum\cite{article:eth}\cite{wood2014ethereum} has an account-based model, where every account represents a state. An account is mapped with a 160 bits address (public key) and there are two types of accounts: \textit{Externally owned account} (EOA), controlled by a private key and (smart) \textit{contract account}, controlled by EVM code. Depending on the account type, an account state is represented by the following four fields: \textbf{Nonce} is a counter that represents the number of transactions or contracts created by the account. \textbf{Balance} is the amount of Ether owned by the account, expressed in Wei~\ref{tab:Ether_metrics}. \textbf{Storage hash} is the root hash of a merkle tree that represents the contents of the account. \textbf{Code hash} is the hash that points to the EVM code that the account has.
\begin{figure}[htp]
	\centering
	\includegraphics[width=0.8\textwidth]{./images/accounts}
	\caption{Ethereum Accounts\cite{evm-illustrate}}
	\label{fig:accounts}
\end{figure}

\subsubsection{Transactions and Messages}
A \textbf{transaction} is a cryptographically-signed message that can only be sent by an EOA. Transactions can trigger a state change on the blockchain or the execution of EVM code. Transactions can be divided into two groups:
\begin{itemize}
	\item  \textbf{Message calls}: The transactions between accounts.
	\item \textbf{Contract creations}: creation of a new account with EVM code in its data/code field.
\end{itemize}
\textbf{Messages} can be seen as internal transactions between contracts triggered by a message call. A message is like a transaction but produced by a contract. This way messages enable contracts to interact between them.
\subsection{Ethereum Virtual Machine (EVM)}\label{sec:evm}
The EVM\cite{wood2014ethereum}\cite{book:masteringETH-evm} is a quasi-Turing-complete machine; the quasi means that its computation is limited by the available \textbf{gas}~\ref{sec:gas} that the executed contract bytecode has, preventing that accidentally or malicious contracts execute forever. Thus, denial-of-service attacks are not possible on Ethereum. The EVM is a stack machine with 1024 elements. It is big-endian by design with 256-bit word size, which facilitates hashing and elliptic curve operations (Keccak-256 hashes and secp256k1 signatures). In addition to the {\textbf{Stack}}, the machine has two more  spaces where operations can access and store data: {\textbf{Memory}}; volatile and initialized to zero. \textbf{Account storage}; non-volatile and maintained as part of the Ethereum state, also initialized to zero. Lastly, the EVM code is stored in a separate virtual read-only memory (\textbf{ROM}).
\begin{figure}[htp]
	\centering
	\includegraphics[width=0.65\textwidth]{./images/evm}
	\caption{Ethereum Virtual Machine\cite{evm-illustrate}}
	\label{fig:accounts}
\end{figure}
\subsubsection{Ether and Gas}\label{sec:gas}
Ether (ETH) is the native cryptocurrency of Ethereum. Ether is used to pay for transaction fees or EVM computing power in the form of gas units. For example, the cost or gas limit for sending a transaction is 21000 gas units\cite{wood2014ethereum-Fee}. The price for a gas unit is represented in gwei, and is set by the participants of the consensus protocol (miners), based on the supply and demand of the network computational power\cite{book:masteringETH-gas}.
For instance, with an average gas price of 15 gwei\cite{gastracker}, sending a transaction at the moment of writing this Thesis would cost: $21000*15 = 315000~Gwei$ or $0.000315~Ether.$
\begin{table}[htp]
\centering
%\begin{center}
\begin{tabular}{|l|l|l|}
	\hline
	\multicolumn{1}{|c|}{\textbf{Unit Name}} & 
	\multicolumn{1}{|c|}{\textbf{Wei Value}} \\\hline
	$Ether$ & $1^{18}$  \\\hline
	$Gwei$  & $1^{9}$  \\\hline
	$Wei$   & $1$     \\\hline   
\end{tabular}
\caption{Important metrics of $Ether$}
\label{tab:Ether_metrics}
%\end{center}
\end{table}

\subsection{Smart Contracts}\label{sec:sc}
In the Ethereum network, a smart contract\cite{book:masteringETH-sc-solidity}\cite{smartcontracts} is a computer program that is executed by the EVM. Since smart contacts are also a type of account, see~\ref{sec:accounts}, they have a balance and can send transactions in the form of messages. Furthermore, smart contracts have the following properties:
\setdescription{font=\normalfont}
\begin{description}[style=nextline] %% Style for this list only.
	\item[\textit{Immutability}] When a smart contract is deployed to the Ethereum platform, the code can not be changed. If a modification (fixing a bug or adding new functionality) needs to be made, a new smart contract needs to be deployed.
	\item[\textit{Determinism}] Given an input and the blockchain state, the result of the execution of the smart contract has to be the same for everyone who calls the contract.
	\item[\textit{Limitations}] By design, smart contracts can not send $HTTP$ requests; this can be solved using decentralized oracles\cite{oracles}. Furthermore, the context of execution is limited to the EVM, meaning that they can only access their own state and the transaction context of the transaction caller. Lastly, smart contracts can not exceed the size of $24KB$.
	\item[\textit{Lifecycle}] Once deployed, smart contracts can no be modified. However, they can be deleted if the smart contract was programed with the $selfdestruct()$ function.
	\item[\textit{Composability}] Since smart contracts can call other smart contracts, functionality of different contracts can be combined. However, such interaction between contracts has to be triggered by a transaction sent by an EOA.
	\item[\textit{Permissionless}] Anyone can deploy a smart contract to the Ethereum network.    
\end{description}
Smart contracts can be written in EVM bytecode\cite{evmbytecode}. However, they are usually written in high-level programming languages such as \textit{Solidity}, \textit{Vyper}\cite{vyper} and \textit{Fe}\cite{fe}, among others, being Solidity, the most widely used programming language for smart contracts in EVM-based blockchains. \textbf{Solidity}\cite{book:masteringETH-sc-solidity}\cite{solidity} is an object-oriented or contract-oriented high-level programming language; it was created by Dr Gavin Wood and designed to target the EVM.  The Solidity compiler $solc$ converts Solidity contracts into EVM bytecode and also generates the contract application binary interface (ABI)\cite{abi}, which enables the interaction with contracts in both directions; from outside the blockchain and from contract to contract.
 
\subsection{Tokens}\label{sec:tokens}
Tokens have a widely used description\cite{wiki:Token}, in the context of Ethereum; a token\cite{tokens} is a digital representation or abstraction of something that lives on the Blockchain. For instance, tokens can represent currencies, shares in a company, or even a virtual pet. Unlike Ether, which is managed by the Ethereum protocol, tokens are created and handled by smart contracts. Everyone can create a token. Nonetheless, because a smart contract can be programed without any restriction, there are standards that need to be followed for the creation of tokens. The two most used standards are:

The \textbf{ERC20} Token Standard\cite{erc20}, for the representation of equivalent and interchangeable tokens (fungible tokens). For instance, a token that represents a currency or a share in a company. As defined in the EIP\cite{erc20}, the ERC20 contract is composed of the following elements:
\begin{table}[htp]
	\centering
	%\begin{center}
	\begin{tabular}{|l|l|l|}
		\hline
		\multicolumn{1}{|c|}{\textbf{~Must have methods~~~}} & 
		\multicolumn{1}{|c|}{\textbf{~Optional methods~~~}}  &
		\multicolumn{1}{|c|}{\textbf{~Must have events~~~}} \\\hline
		 $~totalSupply()$& $~name()$  & $~Transfer()$  \\
		 $~balanceOf()$& $~symbol()$ & $~Approval()$  \\
		 $~transfer()$& $~decimals()$  &  \\
		 $~transferFrom()$&  &   \\
		 $~approve()$&  &   \\
		 $~allowance()$&  &   \\\hline		 
	\end{tabular}
	\caption{Components of the ERC20 Standard.}
	\label{tab:erc20}
	%\end{center}
\end{table}



The \textbf{ERC721} Token Standard\cite{erc721}, for non-fungible tokens or representation of unique goods like an ID or collectibles.

\subsection{Decentralized Applications (Dapps)}\label{sec:dapps}
Unlike a web application, a Dapp has its backend running on a decentralized per-to-per network such as Ethereum, inheriting the advantages and drawbacks that the network has. 

%%%%% Chapter
\chapter{Decentralized Finance (DeFi)} \label{ch:defi}
\section{Maker Protocol}
\section{Aave Protocol}
%%%%% Chapter
\chapter{Application Requirements} \label{ch:appreq}
This Chapter describes the application requirements based on ISO/IEC/IEEE 29148:2018\cite{iso} Software Requirements Specification standard.

\textbf{Project}: Thesis.
\section{Introduction}
\subsection{Purpose}
The main purpose of this Chapter is to provide a detailed description of the Decentralized application developed for this Thesis. 
\subsection{Scope}
Requirements for a decentralized application that can provide
permissionless financial services using an evm based blockchain.

The minimum viable functionality that the application shall offer the users are:
\begin{itemize}
	\item Sign in with the metamask wallet.
	\item See which tokens can be deposited.
	\item Using Aave: Deposit cryptoassets and earn interest. 
	\item Using Aave: Withdrawal of deposited assets.
\end{itemize}
The application runs online; its frontend may not be decentralized, but its backend runs on top of an EVM-based blockchain such as Polygon Testnet or Mainnet.
\subsection{Product Perspective}
\subsubsection{Interface}
The application runs in the latest version of Chrome, Firefox, Brave browsers on Windows, Linux and Mac.

\section{Requirements}
\subsection{Functional}
\subsubsection{Login}
[Thesis-SRS-01] The application shall allow users to login using the Metamask\cite{wiki:MetaMask} wallet.

[Thesis-SRS-02]  If the wallet is set with another network, the application should let the user change to the application network with just one button click.

[Thesis-SRS-03] The application shall display the user balance of the supported assets.

[Thesis-SRS-04] The application shall display the user balance of deposit assets and earnings.

[Thesis-SRS-05] The application shall display the interest rates for the supported assets.
\subsubsection{Deposit}
[Thesis-SRS-06] The application shall allow users to deposit Ether to earn interest.

[Thesis-SRS-07] The application shall allow users to deposit DAI to earn interest.

[Thesis-SRS-08] The application shall convert Ether to Weth, because the protocol only accepts Ether in the form of ERC20, i.e. Weth.

[Thesis-SRS-9] The application shall display the user balance after any deposit transaction.

\subsubsection{Withdrawal}
[Thesis-SRS-10] The application shall allow users to withdraw deposited cryptoassets.

[Thesis-SRS-11] The application shall display the user balance after any withdrawal transaction.

\subsection{Nonfunctional}
\subsubsection{Login}
[Thesis-SRS-12] While not logged in, the application should display the available assets to be deposited and its interest rates. 
\subsubsection{Deposit}
[Thesis-SRS-13] The application should display a notification after any deposit transaction.
\subsubsection{Withdrawal}
[Thesis-SRS-14] The application should display a notification after any withdrawal transaction.
\subsubsection{Performance}
[Thesis-SRS-15] The transaction cost should be minimized by using the Polygon network.

\newpage
\section{Use Case}
The following use case diagram describes the minimum functionality that the application shall have.

\begin{figure}[htp]
	\centering
	\includegraphics[width=1\textwidth]{./images/USECASE-mvp}
	\caption{Use Case Diagram: Minimum Viable Product.}
	\label{fig:usecase-mvp}
\end{figure}
\newpage
If the development process goes well and there is enough time, the application should add more functionalities as illustrated in the following use case diagram. The requirement document/chapter\cite{ch:appreq} should also be updated.
\begin{figure}[htp]
	\centering
	\includegraphics[width=0.97\textwidth]{./images/USECASE-full}
	\caption{Use Case Diagram: Expected Application Functionality.}
	\label{fig:usecase-mvp}
\end{figure}


%%%%% Chapter
\chapter{Implementation and testing} \label{ch:impl}
%\section{Defining the tech stack}
\section{Node Provider}
\subsection{Alchemy}
\section{Intearction with the smart contracts: Backend}
\subsection{Web3.py: Brownie}
\subsection{Testing: pytest}
\section{Interaction with the users: Frontend}
\subsection{Ethers.js: wagmi}
\subsection{Next.js}
\subsection{Testing: mochajs}
%%%%%
%%%%% Chapter
\chapter{Conclusion and future work} \label{ch:conclusion}
\newpage

\bibliographystyle{plain} % Literaturverzeichnis
\begin{btSect}{thesis} % mit bibtopic Quellen trennen
\section*{Bibliography}
\btPrintCited
\end{btSect}
\begin{btSect}{online}
\section*{Online Sources}
\btPrintCited
\end{btSect}
% dann mit "bibtex thesis1" und "bibtex thesis2" arbeiten

\end{document}
;;; Local Variables:
;;; ispell-local-dictionary: "de_DE-neu"
;;; End:
