\documentclass[11pt,a4paper]{report} 
% Alternativ für doppelseitigen Ausdruck (nur bei > 60 Seiten sinnvoll)
% \documentclass[11pt,a4paper,twoside,openright]{report} 

\include{preamble} % alle Pakete und Einstellungen

% Hier anpassen 
\newcommand{\welchethesis}{Bachelor}
% \newcommand{\welchethesis}{Master}
\newcommand{\thesisofwas}{of Science - B.Sc.}
\newcommand{\titel}{Study and implementation of a decentralized application that can provide
	permissionless financial services using an evm based blockchain}
%\newcommand{\kurztitel}{Template Abschlussarbeit}
\newcommand{\autor}{Mario Alberto Maita Orozco}
\newcommand{\datum}{30.06.2022} % Abgabedatum
\newcommand{\ort}{Wiesbaden}
\newcommand{\referent}{Prof.\ Dr.\ Eva-Maria Iwer}
\newcommand{\korreferent}{Prof.\ Dr.\ Marc-Alexander Zschiegner}

\begin{document}
\include{vorspann} % Titelseite, Erklärungen, etc.

\begin{abstract} 
abstract
\end{abstract}

\tableofcontents
\newpage 

\chapter{Introduction} \label{ch:intro}
%\epigraphhead[70]{\epigraph{Documentation is like sex: 
%when it is good, it is very, very good; and when it is bad, 
%sit is better than nothing.}{\textit{Dick Brandon}}}



\section{Motivation}
In the last years' blockchain technology has gained a lot of traction and many developers are willing to build applications on top of this technology.
The Ethereum network with the Ethereum Virtual Machine, or EVM~\ref{sec:evm}, (whose state is validated and copied by every node of the network) offers a new way of application development. Meaning that developers can now implement some functionality and deploy it to a public EVM blockchain, making the code/functionality tamper-resistant; in addition, the implemented functionality (or smart contract) can be called by any participant or other code/contracts within the network. This composability allows anyone to interact with already deployed contracts and build other applications on top of them. 
These kinds of applications are called Decentralized applications or Dapps~\ref{sec:dapps}, because they are built on top of a decentralized network such as  Ethereum.

\section{Goals}
The goals of this Thesis are:  study and provide a better understanding of; how Dapps are built, which technology is used, and the development of a Dapp that uses well-known DeFi~\ref{ch:defi} protocols to let users access to permissionless financial services such as lending and borrowing of crypto assets.

\section{Thesis Structure}
The Thesis is divided into the following chapters:
\begin{itemize}
	
	\item \textbf{Chapter ~\ref{ch:background} - Fundamentals}, gives a technical overwiev of the blockchain technology and the Ethereum network.
	\item \textbf{Chapter ~\ref{ch:defi}} ...
	\item \textbf{Chapter ~\ref{ch:appreq}} ...
	\item \textbf{Chapter ~\ref{ch:impl}} ...
	\item \textbf{Chapter ~\ref{ch:conclusion}} ...
\end{itemize}


%%%%%
%%%%% Chapter
\chapter{Fundamentals} \label{ch:background}

\section{Blockchain} \label{sec:bc}
A blockchain\cite{book:bc}\cite{article:bc} is a type of database, which stores data in blocks. These blocks are chronologically ordered by discrete timestamps and linked to each other using cryptographic hash functions\cite{chf}\cite{book:chf}. Commonly, a blockchain is used as a public distributed ledger of transactions records, shared and synchronized by a per-to-per network, where every party can participate in the validation of new blocks based on a consensus protocol, see~\ref{sec:cp}.
The idea of a cryptographically secured chain of blocks was originally presented by Haber and Stornetta\cite{time-stamp} in 1991. However, the implementation and adoption of this technology started with the conception of the bitcoin cryptocurrency whitepaper\cite{bitcoin} in 2008.

\begin{figure}[htp]
	\centering
	\includegraphics[width=0.9\textwidth]{./images/blockchain}
	\caption{View of two blocks in a blockchain}
	\label{fig:bc}
\end{figure}

Determined by the blockchain implementation, block contents can be different. A block usually has a timestamp, the data or transactions record, and the hash value of the previous block in the chain, see figure~\ref{fig:bc}.
The way that a blockchain ensures the security and keeps the integrity of the data is through cryptographic hash functions \ref{sec:chf}, and Merkle trees \ref{sec:mt}

By adding the cryptographic hash value of the previous block  (Block $n$ to Block $n+1$), blockchains ensure the integrity of previous blocks. Because of the second preimage resistance of cryptographic hash functions, see~\ref{sec:chf}, it is computationally infeasible to  find an input other then Block $n$ in order to generate an output = Hash (Block $n$). Due to that, the further the blockchain grows beyond block $n$, the more secure is the integrity of block $n$ and previous blocks.

Depending on who can participate in the consensus protocol, blockchain networks can be divided into two groups: permissionless and permissioned blockchains. This Thesis will be focused on permissionless blockchains that use an EVM, such as the Ethereum network.



\subsection{Cryptographic hash functions}\label{sec:chf}
A cryptographic hash function\cite{chf}\cite{book:chf} maps a given data of variable size to a fixed length \emph{n}-bit string called hash value. $ H : \{0,1\}^* \to \{0,1\}^n $ Such hash functions have the following properties:
\begin{enumerate}
		
	\item \textbf{Collision resistance}: Given $x_1, x_2 $ It should be necessary $ O(2^\frac{n}{2}) $ compute power such that $H(x_1) = H(x_2)$
	
	\item \textbf{Preimage resistance}: For a hash value \emph{h}, it should be necessary $ O(2^n) $ computation power in order to obtain an \emph{x} such that $ H(x)=h $.~~In other words, it should be a one-way function.
	
	\item \textbf{Second preimage resistance}: For an input $x_1$ and its hash value $h_1$, it should be necessary $ O(2^n) $ computation power in order to obtain a $x_2$ such that $H(x_2)=h_1$

	
\end{enumerate}

Such properties prevent attackers from modifying existing blocks keeping the blockchain intact. For example, the bitcoin network uses the SHA-256 hashing algorithm to validate a block, and append it to the chain. This means once a consensus among all the participants is done, and a new block is added, it will be required $ O(2^{256}) $ computation power to tamper with the blockchain. In other words, it is nearly impossible to manipulate an added block as a result of the tremendous computer power that would be needed.

\subsection{Merkle tree}\label{sec:mt}
A Merkle tree\cite{article:merkle}\cite{book:merkle} or hash tree is a binary tree where every leaf node (nodes at the bottom of the tree) is the cryptographic hash value of some data or transaction. A merkle tree is constructed bottom-up; the upwards nodes are the cryptographic hash values of its two child nodes. Therefore, the root node  will contain a complete fingerprint of the entire set of transactions. 

Merkle trees allow secure and efficient data verification using cryptographic hash functions. For example; if a participant in the network needs to verify the validity of these four transactions, see figure~\ref{fig:merkle}, only a check of the root hash value is necessary. Due to the Merkle tree structure, if any of the data blocks is modified, so will be the root hash value. Furthermore, Merkle tree is a very efficient data structure; for instance, checking that a given transaction is included in the tree will take a maximum of $2log (N)$ operations.
\begin{figure}[htp]
	\centering
	\includegraphics[width=0.7\textwidth]{./images/merkle}
	\caption{Merkle tree of four transactions}
	\label{fig:merkle}
\end{figure}
\subsection{Consensus Protocol}\label{sec:cp}
The consensus protocol\cite{article:bc} of a blockchain network gives a specific rule for verifying whether a transaction is valid or not. As mentioned in~\ref{sec:bc}, any participant or node of the network, depending on the blockchain type, can append a new block. For the reason that blockchains typically do not have a centralized authority validating transactions, participants on the blockchain must verify any transaction according to the set of rules or consensus protocol of the blockchain. The most common consensus mechanisms nowadays are:
\begin{itemize}
	\item[] \textbf{Proof of work (PoW)}
	In a PoW blockchain, nodes have to solve a cryptographic task in order to validate a block, the first node to find a solution can submit the transaction. Most of the first blockchains in the space use proof-of-work-based protocols; for example, Bitcoin uses PoW based on the cryptographic hash function SHA-256.	
	\item[] \textbf{Proof of state (PoS)}
	In a PoS blockchain, the entity that can validate a transaction is randomly selected, depending on the "stake" that a node has on the network. Since nodes have a large stake in the blockchain, they will pursue the integrity of the network.

\end{itemize}
\subsection{Public-Key Cryptography}
In order to interact with a blockchain, participants use public key cryptography or asymmetric key cryptography\cite{book:pkc}. The public key acts as the id of the sender or receiver of a given message; and it can be shared with others without any security downfall. On the other hand, the private key should be kept secure and private by the message sender; it is used to sign (digital signature) the messages or transactions, i.e., give permission to change the state of the user records in the blockchain.

\textbf{Digital signature:} The message or transaction can only be signed with a private key, and anyone who knows the public key of the signed message can verify  its authenticity. Meaning that any party of the blockchain can participate in the verification of the transactions/messages.

The private key is a random number and the public key is generated from it using one-way cryptographic hash functions, see \ref{sec:chf} or elliptic curve cryptography\cite{book:pkc}\cite{wiki:ecc}. Elliptic curve cryptography (ECC) is based on the discrete logarithm problem and is the most common public-key algorithm in blockchain networks.
In mathematics terms, an elliptic curve is a plane curve over all the points $(x, y)$ that satisfy the following equation:  $ y^2 = x^3 +ax + b $


\section{Ethereum}
\subsection{Ethereum Virtual Machine (EVM)}\label{sec:evm}
\subsection{Smart Contracts}\label{sec:sc}
\subsection{Solidity}\label{sec:sol}
\subsection{Tokens}\label{sec:tokens}
\subsection{Decentralized Applications (Dapps)}\label{sec:dapps}

%%%%%%%%%%%% FIGURE
%\begin{figure}[htp]
%\centering
%\includegraphics[width=.9\textwidth]{images/cids}
%\caption{Dateien zur Erstellung des Templates}
%\label{fig:templateprozess}
%\end{figure}

%%%%%
%%%%% Chapter
\chapter{Decentralized Finance (DeFi)} \label{ch:defi}

%%%%%
%%%%% Chapter
\chapter{Application requirements} \label{ch:appreq}

%\section{Listings} \label{sec:listings}
%\begin{listing}[htbp]
%\begin{lstlisting}
%def ggt(x, y):
%    while x != 0:
%        x,y = y%x, x
%    return y
%\end{lstlisting}
%\caption{ggT --- kurz und gut}
%\label{code:ggt}
%\end{listing}


%%%%%
%%%%% Chapter
\chapter{Implementation and testing} \label{ch:impl}
\newpage


%%%%%
%%%%% Chapter
\chapter{Conclusion and future work} \label{ch:conclusion}

\newpage

% Listen wenn überhaupt ans Ende und nicht an den Anfang.
% Meist ist das aber unnötig.
%\listoffigures % Liste der Abbildungen 
%\listoftables % Liste der Tabellen
% \newpage

\bibliographystyle{plain} % Literaturverzeichnis
\begin{btSect}{thesis} % mit bibtopic Quellen trennen
\section*{Bibliography}
\btPrintCited
\end{btSect}
\begin{btSect}{online}
\section*{Online Sources}
\btPrintCited
\end{btSect}
% dann mit "bibtex thesis1" und "bibtex thesis2" arbeiten

\end{document}
;;; Local Variables:
;;; ispell-local-dictionary: "de_DE-neu"
;;; End:
