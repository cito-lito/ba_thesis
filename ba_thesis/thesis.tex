\documentclass[11pt,a4paper]{report} 
% Alternativ für doppelseitigen Ausdruck (nur bei > 60 Seiten sinnvoll)
% \documentclass[11pt,a4paper,twoside,openright]{report} 

\include{preamble} % alle Pakete und Einstellungen

% Hier anpassen 
\newcommand{\welchethesis}{Bachelor}
% \newcommand{\welchethesis}{Master}
\newcommand{\thesisofwas}{of Science - B.Sc.}
\newcommand{\titel}{Study and implementation of a decentralized application that can provide
	permissionless financial services using an evm based blockchain}
%\newcommand{\kurztitel}{Template Abschlussarbeit}
\newcommand{\autor}{Mario Alberto Maita Orozco}
\newcommand{\datum}{30.06.2022} % Abgabedatum
\newcommand{\ort}{Wiesbaden}
\newcommand{\referent}{Prof.\ Dr.\ Eva-Maria Iwer}
\newcommand{\korreferent}{Prof.\ Dr.\ Marc-Alexander Zschiegner}
%\usepackage{tabularx}
\usepackage{hyperref}
\hypersetup{
	colorlinks=true,
	linkcolor=blue,
	filecolor=magenta,      
	urlcolor=cyan,
	citecolor=blue,
%	pdftitle={Overleaf Example},
%	pdfpagemode=FullScreen,
}
\begin{document}
\include{vorspann} % Titelseite, Erklärungen, etc.

\begin{abstract} 
abstract
\end{abstract}

\tableofcontents
\newpage 

\chapter{Introduction} \label{ch:intro}
%\epigraphhead[70]{\epigraph{Documentation is like sex: 
%when it is good, it is very, very good; and when it is bad, 
%sit is better than nothing.}{\textit{Dick Brandon}}}



\section{Motivation}
In the last years' blockchain technology has gained a lot of traction and many developers are willing to build applications on top of this technology.
The Ethereum network with the Ethereum Virtual Machine, or EVM~\ref{sec:evm}, (whose state is validated and copied by every node of the network) offers a new way of application development. Meaning that developers can now implement some functionality and deploy it to a public EVM blockchain, making the code/functionality tamper-resistant; in addition, the implemented functionality (or smart contract) can be called by any participant or other code/contracts within the network. This composability allows anyone to interact with already deployed contracts and build other applications on top of them. 
These kinds of applications are called Decentralized applications or Dapps~\ref{sec:dapps}, because they are built on top of a decentralized network such as  Ethereum.
\section{Goals}
The goals of this Thesis are, to study and provide a better understanding of: 
\begin{itemize}
	\item How Dapps are built.
	\item Which technology is used.
	\item And the development of a Dapp that uses well-known DeFi protocols see~\ref{ch:defi}, to let users access to permissionless financial services such as lending and borrowing of crypto assets.
\end{itemize}


\section{Thesis Structure}
The Thesis is divided into the following chapters:
\begin{itemize}
	
	\item \textbf{Chapter ~\ref{ch:background} - Fundamentals}, gives a technical overwiev of the blockchain technology and the Ethereum network.
	\item \textbf{Chapter ~\ref{ch:defi}} ...
	\item \textbf{Chapter ~\ref{ch:appreq}} ...
	\item \textbf{Chapter ~\ref{ch:impl}} ...
	\item \textbf{Chapter ~\ref{ch:conclusion}} ...
\end{itemize}


%%%%%
%%%%% Chapter
\chapter{Fundamentals} \label{ch:background}

\section{Blockchain} \label{sec:bc}
A blockchain\cite{book:bc}\cite{article:bc} is a type of database (append-only data strucuture), which stores data in blocks. These blocks are chronologically ordered by discrete timestamps and linked to each other using cryptographic hash functions\cite{chf}\cite{book:chf}. Commonly, a blockchain is used as a public distributed ledger of transactions records, shared and synchronized by a per-to-per network, where every party can participate in the validation of new blocks based on a consensus protocol, see~\ref{sec:cp}.
The idea of a cryptographically secured chain of blocks was originally presented by Haber and Stornetta\cite{time-stamp} in 1991. However, the implementation and adoption of this technology started with the conception of the bitcoin cryptocurrency whitepaper\cite{bitcoin} in 2008.

\begin{figure}[htp]
	\centering
	\includegraphics[width=0.9\textwidth]{./images/blockchain}
	\caption{View of two blocks in a blockchain}
	\label{fig:bc}
\end{figure}

Determined by the blockchain implementation, block contents can be different. A block usually has a timestamp, the data or transactions record, and the hash value of the previous block in the chain, see figure~\ref{fig:bc}.
The way that a blockchain ensures the security and keeps the integrity of the data is through cryptographic hash functions \ref{sec:chf}, and Merkle trees \ref{sec:mt}

By adding the cryptographic hash value of the previous block  (Block $n$ to Block $n+1$), blockchains ensure the integrity of previous blocks. Because of the second preimage resistance of cryptographic hash functions, see~\ref{sec:chf}, it is computationally infeasible to  find an input other then Block $n$ in order to generate an output = Hash (Block $n$). Due to that, the further the blockchain grows beyond block $n$, the more secure is the integrity of block $n$ and previous blocks.

Depending on who can participate in the consensus protocol, blockchain networks can be divided into two groups: permissionless and permissioned blockchains. This Thesis will be focused on permissionless blockchains that use an EVM, such as the Ethereum network.



\subsection{Cryptographic hash functions}\label{sec:chf}
A cryptographic hash function\cite{chf}\cite{book:chf} maps a given data of variable size to a fixed length \emph{n}-bit string called hash value. $ H : \{0,1\}^* \to \{0,1\}^n $ Such hash functions have the following properties:
\begin{enumerate}
		
	\item \textbf{Collision resistance}: Given $x_1, x_2 $ It should be necessary $ O(2^\frac{n}{2}) $ compute power such that $H(x_1) = H(x_2)$
	
	\item \textbf{Preimage resistance}: For a hash value \emph{h}, it should be necessary $ O(2^n) $ computation power in order to obtain an \emph{x} such that $ H(x)=h $.~~In other words, it should be a one-way function.
	
	\item \textbf{Second preimage resistance}: For an input $x_1$ and its hash value $h_1$, it should be necessary $ O(2^n) $ computation power in order to obtain a $x_2$ such that $H(x_2)=h_1$

	
\end{enumerate}

Such properties prevent attackers from modifying existing blocks keeping the blockchain intact. For example, the bitcoin network uses the SHA-256 hashing algorithm to validate a block, and append it to the chain. This means once a consensus among all the participants is done, and a new block is added, it will be required $ O(2^{256}) $ computation power to tamper with the blockchain. In other words, it is nearly impossible to manipulate an added block as a result of the tremendous computer power that would be needed.

\subsection{Merkle tree}\label{sec:mt}
A Merkle tree\cite{article:merkle}\cite{book:merkle} or hash tree is a binary tree where every leaf node (nodes at the bottom of the tree) is the cryptographic hash value of some data or transaction. A merkle tree is constructed bottom-up; the upwards nodes are the cryptographic hash values of its two child nodes. Therefore, the root node  will contain a complete fingerprint of the entire set of transactions. 

Merkle trees allow secure and efficient data verification using cryptographic hash functions. For example; if a participant in the network needs to verify the validity of these four transactions, see figure~\ref{fig:merkle}, only a check of the root hash value is necessary. Due to the Merkle tree structure, if any of the data blocks is modified, so will be the root hash value. Furthermore, Merkle tree is a very efficient data structure; for instance, checking that a given transaction is included in the tree will take a maximum of $2log (N)$ operations.
\begin{figure}[htp]
	\centering
	\includegraphics[width=0.7\textwidth]{./images/merkle}
	\caption{Merkle tree of four transactions}
	\label{fig:merkle}
\end{figure}
\subsection{Consensus Protocol}\label{sec:cp}
The consensus protocol\cite{article:bc} of a blockchain network gives a specific rule for verifying whether a transaction is valid or not. As mentioned in~\ref{sec:bc}, any participant or node of the network, depending on the blockchain type, can append a new block. For the reason that blockchains typically do not have a centralized authority validating transactions, participants on the blockchain must verify any transaction according to the set of rules or consensus protocol of the blockchain. The most common consensus mechanisms nowadays are:
\begin{itemize}
	\item[] \textbf{Proof of work (PoW)}
	In a PoW blockchain, nodes have to solve a cryptographic task in order to validate a block, the first node to find a solution can submit the transaction. Most of the first blockchains in the space use proof-of-work-based protocols; for example, Bitcoin uses PoW based on the cryptographic hash function SHA-256.	
	\item[] \textbf{Proof of state (PoS)}
	In a PoS blockchain, the entity that can validate a transaction is randomly selected, depending on the "stake" that a node has on the network. Since nodes have a large stake in the blockchain, they will pursue the integrity of the network.

\end{itemize}
\subsection{Public-Key Cryptography}
In order to interact with a blockchain, participants use public key cryptography or asymmetric key cryptography\cite{book:pkc}. The public key acts as the id of the sender or receiver of a given message; and it can be shared with others without any security downfall. On the other hand, the private key should be kept secure and private by the message sender; it is used to sign (digital signature) the messages or transactions, i.e., give permission to change the state of the user records in the blockchain.

\textbf{Digital signature:} The message or transaction can only be signed with a private key, and anyone who knows the public key of the signed message can verify  its authenticity. Meaning that any party of the blockchain can participate in the verification of the transactions/messages.

The private key is a random number and the public key is generated from it using one-way cryptographic hash functions, see \ref{sec:chf} or elliptic curve cryptography\cite{book:pkc}\cite{wiki:ecc}. Elliptic curve cryptography (ECC) is based on the discrete logarithm problem and is the most common public-key algorithm in blockchain networks.
In mathematics terms, an elliptic curve is a plane curve over all the points $(x, y)$ that satisfy the following equation:  $ y^2 = x^3 +ax + b $

%\subsection{Bitcoin}
%The bitcoin network is a set of technologies that enabled for the first time a %decentralized, permissionless, trustless, peer-to-peer digital currency system. %The distributed computation system that bitcoin introduced: the proof-of-work %algorithm to produce a consensus in a distributed system without a central %trusted authority, in combination with the blockchain storage system, solved the %double-spend problem and the Byzantine generals problem.

\section{Ethereum}
The Bitcoin\cite{bitcoin}\cite{book:masteringBTC} network and its set of technologies enabled for the first time a decentralized, permissionless, trustless, peer-to-peer digital currency system. The distributed computation system that bitcoin introduced: a proof-of-work algorithm to produce a consensus in a distributed system without a central trusted authority, in combination with the blockchain storage system, solved the double-spend problem and the Byzantine generals problem, enabling other applicability beyond digital currencies.  In 2014, Vitalik Butering introduced Ethereum\cite{article:eth}, a platform that moved beyond cryptocurrency applications.

Similar to Bitcoin, Ethereum\cite{article:eth}\cite{book:masteringETH} is a distributed transaction-based state machine. However, it is not only a cryptocurrency system. Ethereum is a decentralized computing platform or a decentralized, pseudo-turning complete virtual machine, which runs smart contracts and stores its state changes in its blockchain. Like bitcoin, state changes in ethereum are managed by a consensus mechanism, where everyone can participate in the validation of  blocks or state changes.

\subsection{Accounts}\label{sec:accounts}
Ethereum\cite{article:eth}\cite{wood2014ethereum} has an account-based model, where every account represents a state. An account is mapped with a 160 bits address (public key) and there are two types of accounts: \textit{Externally owned account} (EOA), controlled by a private key and (smart) \textit{contract account}, controlled by EVM code. Depending on the account type, an account state is represented by the following four fields: \textbf{Nonce} is a counter that represents the number of transactions or contracts created by the account. \textbf{Balance} is the amount of Ether owned by the account, expressed in Wei~\ref{tab:Ether_metrics}. \textbf{Storage hash} is the root hash of a merkle tree that represents the contents of the account. \textbf{Code hash} is the hash that points to the EVM code that the account has.
\begin{figure}[htp]
	\centering
	\includegraphics[width=0.8\textwidth]{./images/accounts}
	\caption{Ethereum Accounts\cite{evm-illustrate}}
	\label{fig:accounts}
\end{figure}

\subsubsection{Transactions and Messages}
A \textbf{transaction} is a cryptographically-signed message that can only be sent by an EOA. Transactions can trigger a state change on the blockchain or the execution of EVM code. Transactions can be divided into two groups:
\begin{itemize}
	\item  \textbf{Message calls}: The transactions between accounts.
	\item \textbf{Contract creations}: creation of a new account with EVM code in its data field.
\end{itemize}
\textbf{Messages} can be seen as internal transactions between contracts triggered by a message call. A message is like a transaction but produced by a contract. This way messages enable contracts to interact between them.
\subsection{Ethereum Virtual Machine (EVM)}\label{sec:evm}
The EVM\cite{wood2014ethereum}\cite{book:masteringETH-evm} is a quasi-Turing-complete machine; the quasi means that its computation is limited by the available \textbf{gas} that the executed contract bytecode has, preventing that accidentally or malicious contracts execute forever. Thus, denial-of-service attacks are not possible on Ethereum. The EVM is a stack machine with 1024 elements. It is big-endian by design with 256-bit word size, which facilitates hashing and elliptic curve operations (Keccak-256 hashes and secp256k1 signatures). In addition to the {\textbf{Stack}}, the machine has two more  spaces where operations can access and store data: {\textbf{Memory}}; volatile and initialized to zero. \textbf{Account storage}; non-volatile and maintained as part of the Ethereum state, also initialized to zero. Lastly, the EVM code is stored in a separate virtual read-only memory (\textbf{ROM}).
\begin{figure}[htp]
	\centering
	\includegraphics[width=0.65\textwidth]{./images/evm}
	\caption{Ethereum Virtual Machine\cite{evm-illustrate}}
	\label{fig:accounts}
\end{figure}
\subsubsection{Ether and Gas}
Ether (ETH) is the native cryptocurrency of Ethereum. Ether is used to pay for transaction fees or EVM computing power in the form of gas units. For example, the cost or gas limit for sending a transaction is 21000 gas units\cite{wood2014ethereum-Fee}. The price for a gas unit is represented in gwei, and is set by the participants of the consensus protocol (miners), based on the supply and demand of the network computational power\cite{book:masteringETH-gas}.
For instance, with an average gas price of 15 gwei\cite{gastracker}, sending a transaction at the moment of writing this Thesis would cost: $21000*15 = 315000~gwei$. 
\begin{table}[htp]
\centering
%\begin{center}
\begin{tabular}{|l|l|l|}
	\hline
	\multicolumn{1}{|c|}{\textbf{Unit Name}} & 
	\multicolumn{1}{|c|}{\textbf{Wei Value}} \\\hline
	$Ether$ & $1^{18}$  \\\hline
	$Gwei$  & $1^{9}$  \\\hline
	$Wei$   & $1$     \\\hline   
\end{tabular}
\caption{Important metrics of $Ether$}
\label{tab:Ether_metrics}
%\end{center}
\end{table}

\subsection{Smart Contracts}\label{sec:sc}
In the Ethereum network, a smart contract is a computer program that is executed by the EVM. Since smart contacts are also a type of account, see~\ref{sec:accounts}, they have a balance and can send transactions in the form of messages. Futhermore, smart contracs have the following properties:
Immutability: When a smart contract is deployed to the Ethereum platform, the code can not be changed. If a modification (fix a bug or add new functionality) need to be made, a new smart contract need to be deployed.
Deterministic: Given an input and the blockchain state, the result of the execution of the smart contract has to the same for everyone who calls the contract.
Limitations: By design, smart contracts can not send HTTP request, this can be solve using decentraliced oracles. Futhermore the context of execution is limited to the EVM, meaning that they can only acces to their own state and the transaction context of the trasaction caller. Lastly, smart contracts can not exed the size of 24KB.
Lifecycle: Once deployed, smart contracts can no be modified. However they can be deleted if the smart contract was programed with the selfdestruct() function.
Permissionless: Anyone can deploy a smart contract to the Ethereum network.
Composability: Since smart contracts can call other smart contracts, functionality of diferents contracts can be combined. However a contract can 

\subsubsection{Solidity}\label{sec:sol}
\subsection{Tokens}\label{sec:tokens}
\subsection{Decentralized Applications (Dapps)}\label{sec:dapps}

%%%%%%%%%%%% FIGURE
%\begin{figure}[htp]
%\centering
%\includegraphics[width=.9\textwidth]{images/cids}
%\caption{Dateien zur Erstellung des Templates}
%\label{fig:templateprozess}
%\end{figure}

%%%%%
%%%%% Chapter
\chapter{Decentralized Finance (DeFi)} \label{ch:defi}

%%%%%
%%%%% Chapter
\chapter{Application requirements} \label{ch:appreq}

%\section{Listings} \label{sec:listings}
%\begin{listing}[htbp]
%\begin{lstlisting}
%def ggt(x, y):
%    while x != 0:
%        x,y = y%x, x
%    return y
%\end{lstlisting}
%\caption{ggT --- kurz und gut}
%\label{code:ggt}
%\end{listing}


%%%%%
%%%%% Chapter
\chapter{Implementation and testing} \label{ch:impl}
\newpage


%%%%%
%%%%% Chapter
\chapter{Conclusion and future work} \label{ch:conclusion}

\newpage

% Listen wenn überhaupt ans Ende und nicht an den Anfang.
% Meist ist das aber unnötig.
%\listoffigures % Liste der Abbildungen 
%\listoftables % Liste der Tabellen
% \newpage

\bibliographystyle{plain} % Literaturverzeichnis
\begin{btSect}{thesis} % mit bibtopic Quellen trennen
\section*{Bibliography}
\btPrintCited
\end{btSect}
\begin{btSect}{online}
\section*{Online Sources}
\btPrintCited
\end{btSect}
% dann mit "bibtex thesis1" und "bibtex thesis2" arbeiten

\end{document}
;;; Local Variables:
;;; ispell-local-dictionary: "de_DE-neu"
;;; End:
